#include <iostream>
using namespace std;


int main()
{
	
	int pocz_przedzialu, koniec_przedzialu, dl_przedzialu;
	int lba_krokow=10;

	pocz_przedzialu=0;
	koniec_przedzialu=100;
	dl_przedzialu = pocz_przedzialu-koniec_przedzialu;
	double dx=(dl_przedzialu)/lba_krokow;
	
	//nasz material	
	double D=1;
	int dt=1;//niech bedzie, ze krok czasowy teraz rowna sie 1s
	double **probka;
	probka = new double* [dl_przedzialu];
	for(int i=0; i<dl_przedzialu; i++)
	{
		probka[i]=new double[lba_krokow];
	}
	for(int i=0; i<dl_przedzialu; i++)
	{
		for(int j=0; j<lba_krokow; j++)
		{
			probka[i][j]=0.0;
		}
	}
	for(int i=0; i<dl_przedzialu; i++)
	{
		probka[i][0] = 0.02;
	}
	//to jest tablica stezen
	probka[0][0] = 0.64;

	for(int i=0; i<dl_przedzialu; i++)
	{
		for(int j=1; j<lba_krokow; j++)
		{
			//tu trza indeksy poprawic
			//probka[i][j+1]=probka[i][j-1];
			if(i!=0)
			{
				probka[i][j]=D*(dt/(dx*dx))*(probka[i-1][j-1]+(1+dx/dl_przedzialu)*probka[i+1][j-1]+((dx*dx)/(D*dt) - 2 - (dx/dl_przedzialu))*probka[i][j-1]);
			}
			else
			{
				probka[i][j]=probka[i][j-1];//D*(dt/(dx*dx))*(probka[i][j-1]+(1+dx/dl_przedzialu)*probka[i+1][j-1]+((dx*dx)/(D*dt) - 2 - (dx/dl_przedzialu))*probka[i][j-1]);
			}
		}
	}
	/* 
		wzor: dc/dt = D d2c/dx2; gdzie: 		D - zmienia sie w czasie zgodnie z podana funkcja.
		cz³on dc/dt - ilorazem przednim
		cz³on d2c/dx2 - ilorazem centralnym
	iloraz centralny:
	(u(x+dx)+u(x-dx)-2u(x))/dx2
	u[i+1]+u[i-1]-2u[i]/dx*dx
	iloraz przedni:
	u(x+dx)-u(x)/dx - c[i+1]-c[i]/dt, u nas c[0]=0,64, c[n]=0,02

	Równanie dyfuzji przyblizamy wiec schematem:
	l-dl.probki, 	dt - krok czasowy
	c'[j]=D*dt/dx2*(c[j-1]+(1+dx/l)c[j+1]+(dx2/Ddt - 2- dx/l)c[j])
	*/
	for(int i=0; i<dl_przedzialu; i++)
	{
		for(int j=0; j<lba_krokow; j++)
		{
			cout<<probka[i][j];
		}
		cout<<endl;
	}
	char x;
	cin>>x;
	return 0;
}